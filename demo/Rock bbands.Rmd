---
title: "Rock bbands"
author: "Kenny"
date: "Monday, January 26, 2015"
output: html_document
---

## codes to begin

> 1. deploy quantstrat  
> 2. suppress warnings   
> 3. remove objects from previous runnings
> 4. how does suppressWarnings() work


```{r}

require(quantstrat)
suppressWarnings(rm("order_book.bbands",pos=.strategy)) # to remove object from .strategy environment
suppressWarnings(rm("account.bbands","portfolio.bbands",pos=.blotter)) # to remove from .blotter environment
suppressWarnings(rm("account.st","portfolio.st","stock.str","stratBBands","initDate","initEq",'start_t','end_t')) # to remove from current environment

```

## setup the string name of stocks to test

```{r}

stock.str='IBM' # what are we trying it on
```


## setup some constants as parameters

```{r}

SD = 2 # how many standard deviations, traditionally 2
N = 20 # how many periods for the moving average, traditionally 20

```

## setup currency and stocks further

> 1. primary_id -- String describing the unique ID for the instrument. Most of the wrappers allow this to be a vector.

> 2. currency --  String describing the currency ID of an object of type currency

> 3. multiplier -- Numeric multiplier to apply to the price in the instrument to get to notional value.

```
currency(primary_id, identifiers = NULL, assign_i = TRUE, ...)

stock(primary_id, currency = NULL, multiplier = 1, tick_size = 0.01,
  identifiers = NULL, assign_i = TRUE, overwrite = TRUE, ...)
  
```

```{r}

currency('USD')

stock(stock.str,currency='USD',multiplier=1)

```

### later study

```

##### PLACE DEMO AND TEST DATES HERE #################
#
#if(isTRUE(options('in_test')$in_test))
#  # use test dates
#  {initDate="2011-01-01" 
#  endDate="2012-12-31"   
#  } else
#  # use demo defaults
#  {initDate="1999-12-31"
#  endDate=Sys.Date()}

```

### **why use = not  <-  here?**

## Setup initial data

```{r}

initDate='2006-12-31'
initEq=1000000

portfolio.st='bbands'  # resulting portfolio object
account.st='bbands'

```

# Function introduction

## initPortf()

> **What is it?** -- Constructs and initializes a portfolio object, which is used to contain transactions, positions, and aggregate level values.

```
initPortf(name = "default", symbols, initPosQty = 0,
  initDate = "1950-01-01", currency = "USD", ...)
```

> **name** -- A name for the resulting portfolio object  
> **symbols** -- a list of instrument identifiers for those instruments contained in the portfolio
> **initPosQty** -- Initial position quantity, default is zero

```{r}
portfolio.st
stock.str
initDate
initPortf(portfolio.st,symbols=stock.str, initDate=initDate)

```

## **initPortf() Details**

### Initializes a portfolio object, which is constructed from the following: 
> `$symbols`: the identifier used for each instrument contained in the portfolio. Use ls(Portfolio$symbols) to get a list of symbols.  

> `$symbols$[symbol]$txn`: irregular xts object of transactions data  

> `$symbols$[symbol]$posPL`: regular xts object of positions P&L calculated from transactions  

> `$symbols$[symbol]$posPL.ccy`: regular xts object of positions P&L converted to portfolio currency   

> `$summary`: aggregated portfolio values

### Each symbol has three associated tables. 

> 1. `txn`, is the transactions table, an irregular time series that contains information about trades or other position adjustments with the following columns:
    - `Txn.Qty`: the quantity, usually in units of contracts, changing hands. Positive values indicate a "buy" transaction; negative values are used to indicate a "sell."
    - `Txn.Price`: the price at which the transaction was made,
    - `Txn.Fees`: the sum total of transaction fees associated with the trade,
    - `Txn.Value`: the notional value of the transaction,
    - `Avg.Txn.Cost`: a calculated value for the average net price paid (received) per contract bought (received),
    - `Pos.Qty`: the resulting position quantity of contracts, calculated as the sum of the current transaction and the prior position,
    - `Pos.Avg.Cost`: the calculated average cost of the resulting position, and
    - `Realized.PL`: any prot or loss realized in the transaction from closing out a prior position

> 2. `posPL`, is a container used to store calculated P&L values from transactions and close prices within an instrument. The data series is, however, a regular time series. Columns of the table include:
    - `Pos.Qty` the quantity of the position held in the symbol,
    - `Pos.Value` the notional value of the position,
    - `Txn.Value` the net value of the transactions occuring,
    - `Txn.Fees` the total fees associated with transactions,
    - `Realized.PL` any net prot or loss realized through transactions,
    - `Unrealized.PL` any prot or loss associated with the remaining or open position, and
    - `Trading.PL` the sum of net realized and unrealized prot and loss.

> 3. `posPL.ccy`, is the same as the second but translated into the portfolio currency. For each portfolio, the summary slot contains a table that tracks calculated portfolio information through time. The table contains the following columns, held in a regular xts time series:
    - `Long.Value`: The sum of the notional value of all positions held long in the portfolio.
    - `Short.Value`: The sum of the notional value of all positions held short in the portfolio.
    - `Net.Value`: The sum of the notional long and notional short value of the portfolio.
    - `Gross.Value`: The sum of the notional long and absolute value of the notional short value of the portfolio.
    - `Txn.Fees`: The sum of brokerage commissions, exchange and other brokerage fees paid by the portfolio during the period.
    - `Realized.PL`: The sum of net realized prots or losses aggregated from the underlying positions in the portfolio. Gross realized prots can be calculated by adding Txn.Fees, the brokerage commission expenses for the period.
    - `Unrealized.PL`: The sum total increase or decrease in unrealized profits or losses on open positions in the portfolio at the end of the period.
    - `Net.Trading.PL`: Net realized prot or loss plus interest income plus change in unrealized prot or loss across all positions in the portfolio.

> TODO: add $account: name of the (one) affiliated account Outputs Initialized portfolio structure with a start date and initial positions.


## initAcct()

> **Output hidden** -- Outputs Constructs multi-column xts object used to store aggregated portfolio calculations

```
initAcct(name = "default", portfolios, initDate = "1950-01-01",
  initEq = 0, currency = "USD", ...)

```
> **name** -- Account name, as string  

> **portfolios** -- character vector of strigs naming portfolios included in this account

```{r}

# initAcct(account.st,portfolios='bbands', initDate=initDate)

initAcct(account.st,portfolios= portfolio.st, initDate=initDate)

```


### initAcct() NOTES 

> An **Account object** is a list of portfolios with portfolio summary information

> The Account object is modeled on the CFTC Thirteen-column presentation table. 
    - the first CFTC six column presentations: *Beg.Eq*, *Additions*, *Withdrawals*, *Net.Perf*, *End.Eq*, *Period.ROR*   
    - note: No reason to persist *Period.ROR*, and *Beg.Eq* = Previous *End.Eq*, So we're left with four columns. Note that *Period.ROR* can be calc'd several different ways and is best left as a function.  
    - the remaining 7 columns: - *Commission*, *Net.Realized*, *Interest*, *Ch.Unrealized*, *Advisory.Fees*, *Wealth.Index*   
    - note: Again, no need to add *Wealth.Index*. Eventually, these additional columns will be useful. *Gross.Realized* will be calculated as (Net) `Realized.PL` + `Txn.Fees`  

> TODO Add `calcPeriodROR` function

> TODO Adddd functions `addCapital`, `drawCapital`, `addFees`

> initDate and initEq can be used in addCapital to initalize the account? Track cash at this level??? Calc gross PL and subtract fees? Or calc net PL and add fees.

```{r}

initOrders(portfolio=portfolio.st,initDate=initDate)
```

## **initOrders()**

> This function sets up the **order container** by portfolio.  

> Usage  `initOrders(portfolio = NULL, symbols = NULL, initDate = "1999-12-31", ...)`  

> Arguments  
      - `portfolio` text name of the portfolio to associate the order book with  
      - `symbols` a list of identifiers of the instruments to be contained in the Portfolio. The name of any associated price objects (xts prices, usually OHLC) should match these  
      - `initDate` date (ISO8601) prior to the first close price given in mktdata, used to initialize the order book with a dummy order  
      - `...` any other passthrough parameters  

> Details:   
      - If no symbols list is provided (the default) the function will attempt to retrieve the symbols list from the portfolio in the trade blotter.


```{r}

addPosLimit(portfolio.st, stock.str, initDate, 200, 2 ) #set max pos
```

## `addPosLimit`

### purpose

> Many strategies will not be allowed to trade unconstrained. Typically, constraints will include position sizing limits.

### Usage

```
addPosLimit(portfolio, symbol, timestamp, maxpos, longlevels = 1,
  minpos = -maxpos, shortlevels = longlevels)

```

### Arguments

> `portfolio`  text name of the portfolio to place orders in

> `symbol`  identifier of the instrument to place orders for. The name of any associated price objects (xts prices, usually OHLC) should match these

> `timestamp` timestamp coercible to POSIXct that will be the time the order will be inserted on

> `maxpos`  numeric maximum long position for symbol

> `longlevels`  numeric number of levels

> `minpos`  numeric minimum position, default -minpos (short allowed use negative number)

> `shortlevels` numeric number of short levels, default longlevels

### Details

> `addPosLimit` works with `osMaxPos` to set and enforce **position sizing limits**.   
    
> 1. If levels=1, then all order sizing will be in the complete control of the strategy rules, up to the maximum position specified using addPosLimit's `maxpos` and `minpos` arguments.  

> 2. Simply setting a position limit will not do anything. The strategy entry rules also need to specify an the use of order sizing function `osMaxPos`, most typically as an argument to `ruleSignal`.  
    
> 3. `levels` are a simplification of more complex (proprietary) techniques sometimes used for order sizing. the max orderqty returned will be the limit/levels. Obviously the strategy rules could ask for smaller order sizes, but this is the default. **If you don't want to use levels, set them to 1**.  

> 4. It is also important to note that position limits may be time-varying.   
      
>   - If you only want one static maximum position limit, then call `addPosLimit` with a timestamp argument before your first trade.   

>   - If you want time varying limits, typically in response to some rebalancing rule or risk rule, set the `timestamp` at the time which you wish the limit to take effect.  



```{r}

stratBBands <- strategy("bbands")
```

constructor for objects of type 'strategy'

Description

variables passed in dots will be added to the strategy object, and may be used by initialization and wrapup functions, as well as indicators, signals, and rules.

Usage

strategy(name, ..., assets = NULL, constraints = NULL, store = FALSE)
Arguments

name  
character string naming the strategy

...	
any other passthru parameters

assets	
optional list of assets to apply the strategy to, should normally be defined in the portfolio, not here

constraints	
optional portfolio constraints object matching assets

store	
TRUE/FALSE whether to store the strategy in the .strategy environment, or return it. default FALSE

See Also

applyStrategy

#one indicator
stratBBands <- add.indicator(strategy = stratBBands, name = "BBands", arguments = list(HLC = quote(HLC(mktdata)), maType='SMA'), label='BBands')


#add signals:
stratBBands <- add.signal(stratBBands,name="sigCrossover",arguments = list(columns=c("Close","up"),relationship="gt"),label="Cl.gt.UpperBand")
stratBBands <- add.signal(stratBBands,name="sigCrossover",arguments = list(columns=c("Close","dn"),relationship="lt"),label="Cl.lt.LowerBand")
stratBBands <- add.signal(stratBBands,name="sigCrossover",arguments = list(columns=c("High","Low","mavg"),relationship="op"),label="Cross.Mid")

# lets add some rules
stratBBands <- add.rule(stratBBands,name='ruleSignal', arguments = list(sigcol="Cl.gt.UpperBand",sigval=TRUE, orderqty=-100, ordertype='market', orderside=NULL, threshold=NULL,osFUN=osMaxPos),type='enter')
stratBBands <- add.rule(stratBBands,name='ruleSignal', arguments = list(sigcol="Cl.lt.LowerBand",sigval=TRUE, orderqty= 100, ordertype='market', orderside=NULL, threshold=NULL,osFUN=osMaxPos),type='enter')
stratBBands <- add.rule(stratBBands,name='ruleSignal', arguments = list(sigcol="Cross.Mid",sigval=TRUE, orderqty= 'all', ordertype='market', orderside=NULL, threshold=NULL,osFUN=osMaxPos),type='exit')

#alternately, to exit at the opposite band, the rules would be...
#stratBBands <- add.rule(stratBBands,name='ruleSignal', arguments = list(data=quote(mktdata),sigcol="Lo.gt.UpperBand",sigval=TRUE, orderqty= 'all', ordertype='market', orderside=NULL, threshold=NULL),type='exit')
#stratBBands <- add.rule(stratBBands,name='ruleSignal', arguments = list(data=quote(mktdata),sigcol="Hi.lt.LowerBand",sigval=TRUE, orderqty= 'all', ordertype='market', orderside=NULL, threshold=NULL),type='exit')

#TODO add thresholds and stop-entry and stop-exit handling to test

getSymbols(stock.str,from=initDate,index.class=c('POSIXt','POSIXct'))
start_t<-Sys.time()
out<-try(applyStrategy(strategy=stratBBands , portfolios='bbands',parameters=list(sd=SD,n=N)) )

# look at the order book
#getOrderBook('bbands')
end_t<-Sys.time()
print("strat execution time:")
print(end_t-start_t)

start_t<-Sys.time()
updatePortf(Portfolio='bbands',Dates=paste('::',as.Date(Sys.time()),sep=''))
end_t<-Sys.time()
print("updatePortf execution time:")
print(end_t-start_t)

chart.Posn(Portfolio='bbands',Symbol=stock.str)
plot(add_BBands(on=1,sd=SD,n=N))


###############################################################################
# R (http://r-project.org/) Quantitative Strategy Model Framework
#
# Copyright (c) 2009-2012
# Peter Carl, Dirk Eddelbuettel, Brian G. Peterson, Jeffrey Ryan, and Joshua Ulrich 
#
# This library is distributed under the terms of the GNU Public License (GPL)
# for full details see the file COPYING
#
# $Id$
#
###############################################################################

##### PLACE THIS BLOCK AT END OF DEMO SCRIPT ################### 
# book  = getOrderBook(port)
# stats = tradeStats(port)
# rets  = PortfReturns(acct)
################################################################

```